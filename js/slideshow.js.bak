Slideshow = function(element)
{
	if(!element)
	{
		return null;
	}
	
	var _this = this;
	
	this.options = options || {};
	this.index = this.options.startSlide || 0;
	this.speed = this.options.speed || 300;
	this.delay = this.options.auto || 0;
	
	this.container = element;  // <div>
	this.listElement = this.container.children[0];  // <ul>
	
	this.container.style.overflow = 'hidden';
	this.listElement.style.listStyle = 'none';
	
	this.setup();
	this.begin();
	
	if(this.listElement.addEventListener)
	{
		this.listElement.addEventListener('touchstart', this, false);
		this.listElement.addEventListener('touchmove', this, false);
		this.listElement.addEventListener('touchend', this, false);
		this.listElement.addEventListener('webkitTransitionEnd', this, false);
		this.listElement.addEventListener('msTransitionEnd', this, false);
		this.listElement.addEventListener('oTransitionEnd', this, false);
		this.listElement.addEventListener('transitionend', this, false);
		window.addEventListener('resize', this, false);
	}
};

Slideshow.prototype =
{
	setup: function Slideshow$setup()
	{
		this.slides = this.listElement.children;  // <li>
		this.length = this.slides.length;
		
		this.width = window.innerWidth;
		
		// hide the container
		this.container.style.visibility = 'hidden';
		
		if(!this.width)
		{
			return null;
		}
		
		this.listElement.style.width = (this.slides.length * this.width) + 'px';
		
		var index = this.slides.length;
		while (index--) {
			var el = this.slides[index];
			el.style.width = this.width + 'px';
			el.style.display = 'table-cell';
			el.style.verticalAlign = 'top';
		}
		
    this.slide(this.index, 0); 
    
		// hide the container
		this.container.style.visibility = 'visible';
	},
	
	slide: function Slideshow$slide(index, duration)
	{
		var style = this.listElement.style;
		
		if (duration === undefined)
		{
			duration = this.speed;
		}
		
		// set duration speed (0 represents 1-to-1 scrolling)
		style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = duration + 'ms';
		
		// translate to given index position
    style.MozTransform = style.webkitTransform = 'translate3d(' + -(index * this.width) + 'px,0,0)';
    style.msTransform = style.OTransform = 'translateX(' + -(index * this.width) + 'px)';

    // set new index to allow for expression arguments
    this.index = index;
	},
	
	getPos: function Slideshow$getPos() {

		// return current index position
		return this.index;

	},
  
	prev: function Slideshow$prev(delay) {

		// cancel next scheduled automatic transition, if any
		this.delay = delay || 0;
		clearTimeout(this.interval);

		// if not at first slide
		if (this.index) this.slide(this.index-1, this.speed);

	},
	
	next: function Slideshow$next(delay) {

		// cancel next scheduled automatic transition, if any
		this.delay = delay || 0;
		clearTimeout(this.interval);

		if (this.index < this.length - 1) this.slide(this.index+1, this.speed); // if not last slide
		else this.slide(0, this.speed); //if last slide return to start

	},

	begin: function Slideshow$begin() {

		var _this = this;

		var fnCallback = function()
			{
        _this.next(_this.delay);
      };

		this.interval = (this.delay) ? setTimeout(fnCallback, this.delay) : 0;
  
  },
  
	stop: function Slideshow$stop() {
		this.delay = 0;
		clearTimeout(this.interval);
	},

	resume: function Slideshow$resume() {
		this.delay = this.options.auto || 0;
		this.begin();
	},
	
	handleEvent: function Slideshow$handleEvent(e) {
		switch (e.type) {
			case 'touchstart': this.onTouchStart(e); break;
			case 'touchmove': this.onTouchMove(e); break;
			case 'touchend': this.onTouchEnd(e); break;
			case 'webkitTransitionEnd':
			case 'msTransitionEnd':
			case 'oTransitionEnd':
			case 'transitionend': this.transitionEnd(e); break;
			case 'resize': this.setup(); break;
		}
	},
	
	transitionEnd: function Slideshow$transitionEnd(e) {
    
		if (this.delay) this.begin();

		this.callback(e, this.index, this.slides[this.index]);

	},

	onTouchStart: function Slideshow$onTouchStart(e) {
    
		this.start = {

			// get touch coordinates for delta calculations in onTouchMove
			pageX: e.touches[0].pageX,
			pageY: e.touches[0].pageY,

			// set initial timestamp of touch sequence
			time: Number( new Date() )

		};

		// used for testing first onTouchMove event
		this.isScrolling = undefined;

		// reset deltaX
		this.deltaX = 0;

		// set transition time to 0 for 1-to-1 touch movement
		this.element.style.MozTransitionDuration = this.element.style.webkitTransitionDuration = 0;

	},
	
	onTouchMove: function Slideshow$onTouchMove(e) {

		// ensure swiping with one touch and not pinching
		if(e.touches.length > 1 || e.scale && e.scale !== 1) return;

		this.deltaX = e.touches[0].pageX - this.start.pageX;

		// determine if scrolling test has run - one time test
		if ( typeof this.isScrolling == 'undefined') {
			this.isScrolling = !!( this.isScrolling || Math.abs(this.deltaX) < Math.abs(e.touches[0].pageY - this.start.pageY) );
		}

		// if user is not trying to scroll vertically
		if (!this.isScrolling) {

			// prevent native scrolling
			e.preventDefault();

			// cancel slideshow
			clearTimeout(this.interval);

			// increase resistance if first or last slide
			this.deltaX =
				this.deltaX /
				( (!this.index && this.deltaX > 0 // if first slide and sliding left
					|| this.index == this.length - 1 // or if last slide and sliding right
					&& this.deltaX < 0 // and if sliding at all
				) ?
				( Math.abs(this.deltaX) / this.width + 1 ) // determine resistance level
				: 1 ); // no resistance if false

			// translate immediately 1-to-1
			this.element.style.MozTransform = this.element.style.webkitTransform = 'translate3d(' + (this.deltaX - this.index * this.width) + 'px,0,0)';

		}

	},
	
	onTouchEnd: function Slideshow$onTouchEnd(e) {

		// determine if slide attempt triggers next/prev slide
		var isValidSlide =
			Number(new Date()) - this.start.time < 250 // if slide duration is less than 250ms
			&& Math.abs(this.deltaX) > 20 // and if slide amt is greater than 20px
			|| Math.abs(this.deltaX) > this.width/2; // or if slide amt is greater than half the width

		// determine if slide attempt is past start and end
		var isPastBounds =
			!this.index && this.deltaX > 0 // if first slide and slide amt is greater than 0
			|| this.index == this.length - 1 && this.deltaX < 0; // or if last slide and slide amt is less than 0

		// if not scrolling vertically
		if (!this.isScrolling) {

			// call slide function with slide end value based on isValidSlide and isPastBounds tests
			this.slide( this.index + ( isValidSlide && !isPastBounds ? (this.deltaX < 0 ? 1 : -1) : 0 ), this.speed );

		}

	}
};
